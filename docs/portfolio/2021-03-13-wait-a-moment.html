<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="author" content="ubikium" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="Cache-Control" content="max-age=86400, must-revalidate" />
        <title>Ubikium</title>
        <link rel="stylesheet" type="text/css" title="hakyll_theme" href="../css/theprofessional.css" />
        <link rel="stylesheet" type="text/css" title-"syntax_highlighting" href="../css/monokai.css">
        <script src="../assets/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>
    <body>
      <div class="highbar">&nbsp;</div>
        <div id="header">
          <div class="box">
            <div id="logo" class="name">
				<img src="../images/logo-crvdgc.png" class="icon" style="height: 90px;" />
            </div>
            <div id="navigation" class="pageslinks">
              <nav class="menuNav">
                <div class="menuItems">
                <a href="../" class="portfolio/2021-03-13-wait-a-moment.md">Home</a>
                <a href="../about.html" class="portfolio/2021-03-13-wait-a-moment.md">About</a>
                <a href="../archive.html" class="portfolio/2021-03-13-wait-a-moment.md">Portfolio</a>
                </div>
              </nav>
            </div>
        </div>
        </div>
        <div class="container-gallery">
        <div id="content" class="inside">
            <div class="info">
    <h1>(((Wait a moment .) .) .) - Composing Functions with Multiple Arguments</h1>
    Posted on March 13, 2021
    
        by ubikium
    
</div>
<hr>

<h2 id="panel-1-introduction">Panel 1: Introduction</h2>
<p>I saw this <a href="https://www.reddit.com/r/haskell/comments/m06fdx/pointfree/">meme post</a> in r/haskell about point-free Haskell the other day. It’s meant to be sarcastic, I know, but there are actually some good ideas in it. So I might as well write a blog.</p>
<figure>
<img src="../images/point-free.webp" alt /><figcaption>Point-free meme</figcaption>
</figure>
<p>Per the meme, there are four ways to define <code>mapM</code> in terms of <code>sequence</code> and <code>fmap</code>. But actually, you only need to understand their definitions for Panel 1. All the rest can be derived from the first definition, each achieving the goal of point-free to some extent. For our purpose, let’s assume a function <code>composed :: a -&gt; b -&gt; d</code> can be defined in terms of <code>f :: a -&gt; b -&gt; c</code> and <code>g :: c -&gt; d</code>. If we explicitly write out the arguments, then we get the first panel:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">composed ::</span> a <span class="ot">-&gt;</span> b      <span class="ot">-&gt;</span> d</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">f        ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">g        ::</span>           c <span class="ot">-&gt;</span> d</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>composed a b <span class="ot">=</span> g (f a b)</span></code></pre></div>
<p>So our goal can be restated as: to compose <code>f</code> and <code>g</code>, we first accept two arguments, then pass them to <code>f</code>, and finally forward the result to <code>g</code>. Or we can say, we want to <em>wait for two arguments</em> before forwarding the result.</p>
<p>A more familiar case is when we just want to <em>wait for one argument</em>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">composed' ::</span> a      <span class="ot">-&gt;</span> d</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="ot">f'        ::</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ot">g'        ::</span>      c <span class="ot">-&gt;</span> d</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>composed' a <span class="ot">=</span> g' (f' a)</span></code></pre></div>
<p>In this case, we have the usual function composition operator</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>(g <span class="op">.</span> f) a <span class="ot">=</span> g (f a)</span></code></pre></div>
<p>Then it’s easy to see how we can make <code>composed'</code> point-free:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>composed' a <span class="ot">=</span> (g' <span class="op">.</span> f') a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>composed'   <span class="ot">=</span>  g' <span class="op">.</span> f'        <span class="co">-- η reduction</span></span></code></pre></div>
<p>The problem, of course, is how to find a similar operator to wait for two arguments, or in general, wait for <span class="math inline"><em>n</em></span> arguments.</p>
<h2 id="panel-2-curry-or-uncurry-that-is-the-question">Panel 2: <code>curry</code> or <code>uncurry</code>, that is the question!</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>composed <span class="ot">=</span> <span class="fu">curry</span> (g <span class="op">.</span> <span class="fu">uncurry</span> f)</span></code></pre></div>
<p>Panel 2 uses <code>curry</code> and <code>uncurry</code> to bundle the two arguments together into a pair, then wait for the bundle with <code>(.)</code>. When passing the bundle to <code>f</code>, we need to unbundle it.</p>
<p>Recall the definition of <code>curry</code> and <code>uncurry</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="fu">curry</span><span class="ot">   ::</span> ((a, b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="fu">uncurry</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> ((a, b) <span class="ot">-&gt;</span> c)</span></code></pre></div>
<p>Then we can derive Panel 2:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">                   f  ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>           <span class="fu">uncurry</span><span class="ot"> f  ::</span> (a, b) <span class="ot">-&gt;</span> c</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="ot">       g              ::</span>           c <span class="ot">-&gt;</span> d</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>       g <span class="op">.</span> <span class="fu">uncurry</span><span class="ot"> f  ::</span> (a, b) <span class="ot">-&gt;</span> d</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="fu">curry</span> (g <span class="op">.</span> <span class="fu">uncurry</span> f)<span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> d</span></code></pre></div>
<p>This works fine for waiting for two arguments, but it’s not a good example for point-free style or abstraction because it</p>
<ol type="1">
<li>doesn’t separate the composition operator with the actual functions to be composed, they are instead intertwined together.</li>
<li>doesn’t generalize well if we want to wait for three or more arguments, we need to implement <code>curry3</code> and <code>uncurry3</code>.</li>
</ol>
<p>Therefore, we can’t read the intention of the code well. It doesn’t directly express the idea of <em>waiting for two arguments</em>.</p>
<h2 id="panel-3-birds-of-a-feather">Panel 3: Birds of a feather</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>composed <span class="ot">=</span> (<span class="op">.</span>)<span class="op">.</span>(<span class="op">.</span>) g f</span></code></pre></div>
<p>The third panel seems promising, because it separates the operator and the functions, but what on earth is <code>(.).(.)</code>? (spoiler: it’s not on earth!)</p>
<p>I tried very hard to understand it the first time I met it. My current best explanation is as follows:</p>
<p>Recall the partial application of <code>(.)</code>, we have <code>(.) f ≡ (f .)</code>(<span class="math inline">*</span>).</p>
<p>At first, we have <code>(.).(.) g f</code>, so when <code>(.).(.)</code> gets the first argument <code>g</code>, what does it do?</p>
<p>Since it’s a composition of two functions, it will pass <code>g</code> to the latter function and forward the result to the former function.</p>
<p>That is <code>(secondF . firstF) g ≡ secondF (firstF g)</code>. Here we take both <code>secondF</code> and <code>firstF</code> to be <code>(.)</code>. Then</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>(secondF <span class="op">.</span> firstF) g ≡ secondF (firstF g)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>                     ≡ secondF ((<span class="op">.</span>)    g)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>                     ≡ secondF (g <span class="op">.</span>)      <span class="co">-- see (*) above</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>                     ≡ (<span class="op">.</span>)     (g <span class="op">.</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>                     ≡ ((g <span class="op">.</span>) <span class="op">.</span>)          <span class="co">-- see (*) above</span></span></code></pre></div>
<p>Then we apply it to the second argument <code>f</code>, we get <code>(.).(.) g f ≡ (g .) . f</code>.</p>
<p>How can we understand <code>(g .) . f</code> then?</p>
<p>Well, it’s a function composition. So when the first argument <code>a</code> comes, it will be passed to <code>f</code>, and the result will be forward to <code>(g .)</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>(g <span class="op">.</span>) <span class="op">.</span> f <span class="op">$</span> a ≡ (g <span class="op">.</span>) (f a)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>              ≡  g <span class="op">.</span>  (f a)</span></code></pre></div>
<p>Then the second argument <code>b</code> comes, what will it do? Oh, it is again a function composition, so we pass <code>b</code> to the second function <code>(f a)</code>, and then forward the result to <code>g</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>g <span class="op">.</span> (f a) <span class="op">$</span> b ≡ g ((f a) b)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>              ≡ g ( f a  b)</span></code></pre></div>
<p>We achieved our goal.</p>
<p>This can also be understood through the type signature. After the first argument <code>a</code> comes to <code>(g .) . f</code>, it will be passed to <code>f :: a -&gt; b -&gt; c</code>, resulting in <code>f a :: b -&gt; c</code>. Then we can just compose it with <code>g :: c -&gt; d</code> with the usual <code>(.)</code>.</p>
<p>So far, we have established that <code>(g .) . f</code> will wait for two arguments. Also, we know <code>g . f</code> will wait for one argument. Actually, these are special cases for a general pattern:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>g <span class="op">.</span> f         <span class="co">-- wait for 1 more argument</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>(g <span class="op">.</span>) <span class="op">.</span> f     <span class="co">-- wait for 2 more arguments</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>((g <span class="op">.</span>) <span class="op">.</span>) <span class="op">.</span> f <span class="co">-- wait for 3 more arguments</span></span></code></pre></div>
<p>Or equivalently, the operator style:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>(<span class="op">.</span>)         <span class="co">-- wait for 1 more argument</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>(<span class="op">.</span>)<span class="op">.</span>(<span class="op">.</span>)     <span class="co">-- wait for 2 more arguments</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>(<span class="op">.</span>)<span class="op">.</span>(<span class="op">.</span>)<span class="op">.</span>(<span class="op">.</span>) <span class="co">-- wait for 3 more arguments</span></span></code></pre></div>
<p>The type signatures will tell us what they do:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ot">(.)         ::</span> (d <span class="ot">-&gt;</span> e) <span class="ot">-&gt;</span> (          c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> (          c <span class="ot">-&gt;</span> e)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>(<span class="op">.</span>)<span class="op">.</span><span class="ot">(.)     ::</span> (d <span class="ot">-&gt;</span> e) <span class="ot">-&gt;</span> (     b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> (     b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> e)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>(<span class="op">.</span>)<span class="op">.</span>(<span class="op">.</span>)<span class="op">.</span><span class="ot">(.) ::</span> (d <span class="ot">-&gt;</span> e) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> e)</span></code></pre></div>
<p>Although presented in a meme, these are actually quite useful and common higher-order operators. Once you know them, they’re pretty easy to read, remember, and write.</p>
<p><code>(.).(.)</code> is often presented as the first non-trivial example in these operators. It’s called a <em>blackbird</em> operator in <a href="https://www.youtube.com/watch?v=seVSlKazsNk&amp;t=674s">Amar Shah’s talk about point-free</a>, a <em>dot</em> in <a href="https://wiki.haskell.org/Pointfree">the Haskell wiki for point-free</a>.</p>
<p>This family of operators is also an example for Semantic Editor Combinators in <a href="https://www.youtube.com/watch?v=cefnmjtAolY&amp;t=584s">Edward Kmett’s talk about lenses</a>.</p>
<h2 id="panel-4-one-of-them-is-not-like-the-others">Panel 4: One of them is not like the others</h2>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>composed <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">fmap</span> <span class="fu">fmap</span> g f</span></code></pre></div>
<p>In Panel 3, there are three points. BUt i thOught wE weRE DOing poINT-FREe PROGrAmMINg! So for Panel 4, we have three <code>fmap</code> and zero points. A reasonable guess would be that <code>fmap</code> is secretly <code>(.)</code>. But how?</p>
<p>Recall their definitions:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">(.)  ::</span>              (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (   f b) <span class="ot">-&gt;</span> (   f c)</span></code></pre></div>
<p>So here, we are instantiating the functor <code>f</code> to be <code>(a -&gt;)</code>. That is, we partially apply a fixed type <code>a</code> to <code>(-&gt;)</code>, and change the return type variable, resulting in a (covariant) functor.</p>
<p>This functor is known as the <em>Reader</em> functor. We can explicitly define it as <code>data Reader a x = Reader { runReader :: a -&gt; x }</code>. But in Haskell, we can just write <code>((-&gt;) a)</code>.</p>
<p>You can verify that its functor instance must be</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>    <span class="fu">fmap</span> <span class="ot">=</span> (<span class="op">.</span>)</span></code></pre></div>
<p>You can read more about the Reader functor in <a href="https://bartoszmilewski.com/2015/01/20/functors/">this post from Bartosz’s blog</a>.</p>
<p>Back to the meme, if we replace all <code>(.)</code> with <code>fmap</code> in Panel 3, then we get Panel 4.</p>
<p>It’s correct, but really confusing. Without looking at the signature, one can hardly imagine which instance is <code>fmap</code> using, let alone the intention of three <code>fmap</code> being together (the original meme also use <code>fmap</code> as an argument, just to be fun!).</p>
<p>There is, however, a chance to salvage something from Panel 4. Let’s think <code>fmap fmap fmap</code> in terms of itself, instead of being just <code>(.)</code> in disguise.</p>
<p>One way to type check <code>fmap fmap fmap</code> is to let the first <code>fmap</code> be instantiated to the Reader functor <code>fmap</code>, i.e. <code>(.)</code>. Then <code>fmap fmap fmap</code> becomes <code>(.) fmap fmap ≡ fmap . fmap</code>.</p>
<p>The type signature can be derived as</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> <span class="dt">Functor</span> f1 <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f1 a <span class="ot">-&gt;</span> f1 b)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> <span class="dt">Functor</span> f2 <span class="ot">=&gt;</span>             (c    <span class="ot">-&gt;</span> d   ) <span class="ot">-&gt;</span> (f2 c <span class="ot">-&gt;</span> f2 d)</span></code></pre></div>
<p>We can take <code>c</code> to be <code>f1 a</code> and <code>d</code> to be <code>f1 b</code>. Therefore</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot">        ::</span> <span class="dt">Functor</span> f1               <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f1 a <span class="ot">-&gt;</span> f1 b)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot">        ::</span> <span class="dt">Functor</span> f1               <span class="ot">=&gt;</span>             (f1 a <span class="ot">-&gt;</span> f1 b) <span class="ot">-&gt;</span> f2 (f1 a) <span class="ot">-&gt;</span> f2 (f1 b)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="fu">fmap</span> <span class="op">.</span><span class="ot"> fmap ::</span> (<span class="dt">Functor</span> f1, <span class="dt">Functor</span> f2) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b)                   <span class="ot">-&gt;</span> f2 (f1 a) <span class="ot">-&gt;</span> f2 (f1 b)</span></code></pre></div>
<p>So by combining two <code>fmap</code>, we get one functor level <em>deeper</em> into the structure. This is another example of Semantic Editor Combinators also mentioned in <a href="https://www.youtube.com/watch?v=cefnmjtAolY&amp;t=584s">the Kmett talk</a>. The general case is:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot">               ::</span> (<span class="dt">Functor</span> f1)                         <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f3 a           <span class="ot">-&gt;</span> f3 b</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="op">.</span><span class="ot"> fmap        ::</span> (<span class="dt">Functor</span> f1, <span class="dt">Functor</span> f2)             <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f3 (f2 a)      <span class="ot">-&gt;</span> f3 (f2 b)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span><span class="ot"> fmap ::</span> (<span class="dt">Functor</span> f1, <span class="dt">Functor</span> f2, <span class="dt">Functor</span> f3) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f3 (f2 (f1 a)) <span class="ot">-&gt;</span> f3 (f2 (f1 b))</span></code></pre></div>
<p>We go one functor level deeper for each <code>fmap</code> composed. Keep digging this way, then you might find some lens for yourself!</p>
<h2 id="conclusion-whats-the-point-of-point-free-anyway">Conclusion: What’s the point of point-free anyway?</h2>
<p>The goal of the point-free style is the same as all other forms of abstraction: to express your intention in a <em>concise</em> (to write), <em>clear</em> (to read), and <em>general</em> (to change) way. All fore-mentioned methods can be summarized as follows:</p>
<div class="table-wrapper">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Definition</th>
<th style="text-align: center;">Point-free</th>
<th style="text-align: center;">Concise</th>
<th style="text-align: center;">Clear</th>
<th style="text-align: center;">General</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>composed a b = g (f a b)</code></td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">O</td>
<td style="text-align: center;">X</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>composed = curry (g . uncurry f)</code></td>
<td style="text-align: center;">O</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">X</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>composed = (.).(.) g f</code></td>
<td style="text-align: center;">O</td>
<td style="text-align: center;">O</td>
<td style="text-align: center;">O*</td>
<td style="text-align: center;">O*</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>composed = fmap fmap fmap g f</code></td>
<td style="text-align: center;">O</td>
<td style="text-align: center;">O</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">O*</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>composed = (fmap . fmap) g f</code></td>
<td style="text-align: center;">O</td>
<td style="text-align: center;">O</td>
<td style="text-align: center;">O*</td>
<td style="text-align: center;">O*</td>
</tr>
</tbody>
</table>
</div>
<p>(*): some experience required</p>
<p>Conclusions:</p>
<ol type="1">
<li>If you need clarity and don’t want to surprise others, go for Panel 1, write all arguments explicitly: <code>composed a b = g (f a b)</code>.</li>
<li>Not every point-free change is guaranteed to be an improvement. You should avoid Panel 2 style (point-free for the sake of point-free) as much as possible. A point-free change should have a strong semantic encoding.</li>
<li>For Panel 3 and modified Panel 4, we can see the power of good point-free usage. We find a pattern (<code>(.).(.)</code> and <code>fmap . fmap</code>) with almost all of the advantages. However, they might be difficult to understand for those who are unfamiliar. And it takes a great deal of efforts to find a new one. Therefore, it’s good for in-house use.</li>
<li>For the original Panel 4, try not to hide your intention. Replace some instances of <code>fmap</code> with its concrete instance to avoid repetition and ambiguity (even just for humans).</li>
</ol>
<hr />
<p>Edit notes:</p>
<ul>
<li>The <code>(.).(.)</code> is called a <em>blackbird</em>, a special kind of bird. That is to say, it’s a special case of an operator in a family of operators. Thanks for Jean-Baptiste Mazon to point it out.</li>
</ul>

        </div>
        </div>
        <div id="footer">
          <div class="inside">
            <p>
			网页使用 <a href="http://jaspervdj.be/hakyll">Hakyll</a> 生成<br />
			字体：中文 - 思源宋体, Serif - <a href="https://github.com/SorkinType/Merriweather">Merriweather</a>, Monospace - <a href="https://github.com/tonsky/FiraCode">FiraCode</a><br />
			主题改编自 The Professional， 设计者 <a href="http://twitter.com/katychuang">Dr. Kat</a><br />
            </p>
            <p class="copyright">
                所有内容均以 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a> 授权。非商用转载无需征得同意，注明出处即可。
            </p>
          </div>
        </div>
    </body>
</html>
